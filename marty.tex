\documentclass[a4paper,12pt,twoside,BCOR=10mm]{scrbook}

% Packages
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[icelandic, english]{babel}
\usepackage{t1enc}
\usepackage{graphicx}
\usepackage[intoc]{nomencl}
\usepackage{enumerate,color}
\usepackage{url}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{appendix}
\usepackage{eso-pic}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[nottoc]{tocbibind}
\usepackage[sort&compress,authoryear]{natbib}
\usepackage[sf,normalsize]{subfigure}
\usepackage[format=plain,labelformat=simple,labelsep=colon]{caption}
\usepackage{placeins}
\usepackage{tabularx}
% Configurations
\graphicspath{{img/}{../img/}}

\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0cm}
\raggedbottom
% \setkomafont{subsection}{\normalfont\sffamily}

% Eins og templatið á að vera
% \setkomafont{captionlabel}{\itshape}
% \setkomafont{caption}{\itshape}

% Mun fallegri lausn
\setkomafont{captionlabel}{\itshape}
\setkomafont{caption}{\itshape}
\setkomafont{section}{\FloatBarrier\Large}
\setcapwidth[l]{\textwidth}
\setcapindent{1em}


% Times new roman
%\usepackage[T1]{fontenc}
%\usepackage{mathptmx}

%%%%%%%%%%% MODIFY THESE LINES ONLY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\thesisyear{2013}       						% Year thesis submitted
\def\thesismonth{October}						% Month thesis submitted
\def\thesisauthor{Baldur Þór Emilsson}					% Thesis authoreiningaraðferðinni
\def\thesistitle{Marty: Application Development and Testing with Production Data in PostgreSQL} % Title of thesis
\def\thesisshorttitle{Development and Testing with Production Data} 	% Title of thesis
\def\thesiscredits{60} 							% Credits awarded for the project
\def\thesissubject{Computer Science}
\def\thesiskind{M.Sc.}							% Masters of PhD thesis
\def\thesiskindformal{Magister Scientiarum}				% Masters of PhD thesis
\def\thesisnroftutors{1}						% Number of tutors
\def\thesisschool{School of Engineering and {Natural Sciences}}		% School
\def\thesisfaculty{Industrial Engineering,\\Mechanical Engineering and\\Computer Science} % Faculty
\def\thesisaddress{Hjarðarhaga 2-6}					% Office address
\def\thesispostalcode{107, Reykjavik}					% Office address
\def\thesistelephone{525 4700}						% Office telephone
\def\thesistutors{Hjálmtýr Hafsteinsson}
\def\thesisrepresentative{XXNN3}					% Tutors name
\def\thesisPrinting{Háskólaprent, Fálkagata 2, 107 Reykjavík}

% Function to add footer to frontpage
\newcommand\BackgroundPic{
\put(0,0){
\parbox[b][\paperheight]{\paperwidth}{
\vfill
\centering
\hspace*{-0.6cm}
\includegraphics[width=\paperwidth,height=\paperheight,
keepaspectratio]{foot}
}}
\setlength{\unitlength}{\paperwidth}
\begin{picture}(0,0)(0,-0.15)
\put(0,0){\color{white}\parbox{1\paperwidth}{\centering\bfseries\sffamily \Large Faculty of \thesisfaculty \\
University of Iceland\\
\thesisyear}}
\end{picture}
}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\AddToShipoutPicture*{\BackgroundPic}
%
\begin{center}
\vspace*{1cm}
\includegraphics[width=43.6mm]{ui_1_cmyk}\\
\vspace*{3.0cm}
\huge \sffamily \bfseries \thesistitle

\vspace*{5.5cm}
\normalfont \Large \sffamily \thesisauthor
\AddToShipoutPicture*{\BackgroundPic}
\vfill

\end{center}

\newpage 
\thispagestyle{empty} \mbox{}
\newpage
\vspace*{1.35cm}
\thispagestyle{empty}
\begin{center}

\Large \textbf{\sffamily{\MakeUppercase{\thesistitle}}} \\

\vspace*{1.7cm}
\sffamily{\thesisauthor} \\
\vspace*{1.8cm}
\normalsize \thesiscredits~ECTS thesis submitted in partial fulfillment of a \\
\textit{\thesiskindformal} degree in \thesissubject

\vspace*{1.0cm}
\large
\ifnum\thesisnroftutors >1 Advisors \\ \thesistutors \\ \vspace*{0.4cm}
\else Advisor \\ \thesistutors \\ \vspace*{1.04cm}
\fi
Faculty Representative \\
\thesisrepresentative

\vfill
Faculty of \thesisfaculty \\
\thesisschool \\
University of Iceland \\
Reykjavik, \thesismonth~\thesisyear
\newpage
\end{center}
 \newpage
 \thispagestyle{empty}
 \mbox{} \vfill
 % \setcounter{page}{0} \renewcommand{\baselinestretch}{1.5}\normalsize
 \sffamily{\thesistitle} \\
 \sffamily{\thesisshorttitle} \\
 \thesiscredits ~ECTS thesis submitted in partial fulfillment of a \thesiskind~degree in \thesissubject
\\ \\
Copyright \textcopyright~\thesisyear~ \thesisauthor \\
All rights reserved \\


Faculty of \thesisfaculty \\
\thesisschool \\
University of Iceland \\
\thesisaddress \\
\thesispostalcode, Reykjavik \\
Iceland

Telephone: \thesistelephone \\ \\
\vspace*{\lineskip}

Bibliographic information: \\
\thesisauthor, \thesisyear, \thesistitle, \thesiskind~thesis, Faculty of \thesisfaculty, University of Iceland. \\

Printing: \thesisPrinting \\
Reykjavik, Iceland, \thesismonth~\thesisyear \\
\newpage
\end{titlepage}


\pagenumbering{roman}

\setcounter{page}{3}
\section*{\huge Abstract}
Marty is a proof-of-concept prototype for a framework that offers convenient application development and testing against data used in production that is stored in the PostgreSQL database management system.
It is designed for minimal overhead and configuration on production servers while offering quick and simple database initialization on development and testing servers.
This opens the possibility for application testing on production data with minimal effort, which complements conventional testing datasets and helps preventing bugs from entering production code which were not caught with the conventional datasets.
\vfill \vspace*{1cm}
\section*{\huge Útdráttur}
Marty er hugbúnaðarlausn sem býður upp á þægilegt þróunar- og prófunarumhverfi fyrir forrit sem nota PostgreSQL gagnagrunnskerfið.
Hún er hönnuð til að nota gögn úr gagnagrunnum sem keyra í raunumhverfi án þess að hafa neikvæð áhrif á afköst netþjónanna sem grunnarnir keyra á og án mikilla breytinga á uppsetningu þeirra en bjóða á sama tíma upp á fljótlega og einfalda uppsetningu þróunar- og prófunargagnagrunna.
Það opnar fyrir möguleikann á hugbúnaðaprófunum með raungögnum án mikillar fyrirhafnar sem geta keyrt samhliða prófunum með hefðbundin prófunargagnasett og hjálpað við að uppræta villur sem koma ekki í ljós með hefðbundnum prófunum.
\vfill
\newpage

\tableofcontents
\listoffigures
\listoftables

\chapter*{Abbreviations}
\addcontentsline{toc}{chapter}{Abbreviations}
Í þessum kafla mega koma fram listar yfir skammstafanir og/eða breytuheiti. Gefið kaflanum nafn við hæfi, t.d. Skammstafanir eða Breytuheiti. Þessum kafla má sleppa ef hans er ekki þörf. \\

The section could be titled: Glossary, Variable Names, etc.

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}
Í þessum kafla koma fram þakkir til þeirra sem hafa styrkt rannsóknina með fjárframlögum, aðstöðu eða vinnu. T.d. styrktarsjóðir, fyrirtæki, leiðbeinendur, og aðrir aðilar sem hafa á einhvern hátt aðstoðað við gerð verkefnisins, þ.m.t. vinir og fjölskylda ef við á. Þakkir byrja á oddatölusíðu (hægri síðu).


\chapter{Introduction}
\pagenumbering{arabic}
\setcounter{page}{1}
Database management systems (DBMS) are used as datastores in many different systems in various fields.
They are rarely used as standalone products and are usually used to store data from other applications.
These applications are often in constant development with short development cycles, which include both manual and automated testing.
Those  tests are often run against datasets that are created to test for specific conditions and ideally they help with catching all bugs before they enter production. However, many projects can benefit from tests that are run against data from the production environment, either to complement the testing datasets or to provide data to test against in situations where no testing datasets exist.
The main disadvantage of using production data in testing is that cloning a large database can take a long time which slows down testing and development and it adds an overhead to the database in production which can have negative effects on the performance of the application in the production environment.

The goal of Marty is to offer a convenient and relatively efficient way to run tests for applications that use the PostgreSQL (Postgres) DBMS against the live data on the production servers without adding overhead to them.
This is achieved by creating a testing database with empty tables that are populated  when they are first queried.
This saves time as only the tables which are used in the tests are populated and no time is spent copying the data for the other tables, which remain empty.
The data is not copied directly from the production server but from another instance of Postgres that stores a copy of the production data.
This is done to ensure the consistency of the data in the cloned databases and also to minimize the load on the production database.
A byproduct of this architecture is the possibility to inspect the state of the production database as it was at a certain point in time.

% TODO rewrite this section when the thesis is complete: The rest of this thesis is organized as follows: chapter 2 contains details about the history of Postgres and its internals that are relevant to Marty. In chapter 3 the design of Marty is described along with reasoning for why this design was chosen and some details about the implementation of Marty. The fourth and final chapter contains conclusions and future work.

\chapter{Goals and purpose of Marty}
The goal of the development of Marty was to create an application that enabled its users to clone a running database quickly.
The original idea was that software developers and testers should be able to clone a database that is used in production and stores large amounts of data that would normally take a considerable time to copy to another server.
Marty should speed up development and testing by reducing the time it takes to clone the production database and should also use techniques that reduce or prevent any negative impact that the cloning would have on the performance of the production database. 

Although the initial idea was for production databases to be cloned there should not be anything that prevents Marty to be used for other kinds of databases, such as databases that are dedicated to storing test datasets that never enter production, as long as those databases fulfill the requirements for Marty.

The emphasis in the design and development of Marty was to minimize the time from when the cloning of a database was initialized and until the newly created clone could be used for testing.
The performance of the newly created database was not a high priority as it was not intended to be used in a performance critical environment.
Thus Marty is not a solution that should be used to create clones of a database that are to be used for load balancing or failover or serve any other role in the production envorinment of an application.

Marty is supposed to be used in an environment where a one or a few databases need to be cloned regularly.
The architecture that was chosen for Marty requires a system administrator to set up and configure Marty for the environment where it is used.
This involves running a dedicated Postgres instance that is used as a reference when the clones are created and also configuring the production server to work with this dedicated instance in a certain way, which might require the production server to be restarted.
It should therefore be clear that Marty is not suited for cloning a database that only needs to be cloned for a limited number of times and should be most useful when the database to be cloned is large enough, or is expected to grow enough, that the time saved by using Marty justifies the initial setup.


\chapter{Architecture}
This chapter contains a detailed description of the architecture and design of Marty.

\section{Overview}
Marty consists of a few parts that serve different pruposes, see figure \ref{architecture-overview}.
Developers and testers that use Marty in their work create database \textit{clones}.
These databases are clones of the \textit{master} database, which can be a database that is used in a production environment.
When the clones are created they are initialized with a copy of all the tables in the master, but the tables remain empty until they are queried by a user or an application.
The design of the clone databases is discuessed in chapter \ref{sec:clones}.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{architecture}
  \caption{An overview of the architecture of Marty}
  \label{architecture-overview}
\end{figure}

Marty does not inspect the schema of the master database directly when it creates the tabes in the clone databases.
Instead it queries another database that is called \textit{history}.
The history database contains information about the schema of the master database as well as a copy of its data.
When the clones need to populate their tables they also use this history database as a reference.
The reason for using another database to store a copy of the schema and data of the master database is discussed in chapter TODO, along with a description of the design of the history database.

As the name suggests the history database contains not only a copy of the current version of the master but also of previous versions.
To update the history database with new versions of the master and to keep it in sync with the changes that are made on the master Marty uses a log from the master that is called the \textit{write-ahead log} or \textit{WAL}.
It does not read this log directly but uses a specially patched instance of Postgres to read the contents of the log.
This instance is called \textit{slave} and it outputs information that Marty can use to update the history database with all the changes that have been made in the master database.
The reason for keeping old versions of the master database and the relationship between the master, slave and history databases is described in detail in chapter TODO.

\section{The clone databases}
\label{sec:clones}
A clone database is a standard Postgres database.
It uses two Postgres extensions; the \textit{PL/pgSQL} extension that enables users to create stored procedures, and the \textit{dblink} extension which enables users to query another database directly from the clone database without using any external scripts or programs.
The clone can run on a local instance of Postgres on the developers' or testers' computer as long as the history database is accessible from that computer.
More than one clone database can run in parallel on the same instance of Postgres so each user can use many clones at the same time.

To create a clone the user creates a new, empty database.
She then initializes it with Marty.
After the clone has been initialized it contains all the schemas that are found in the master database and a copy of all the tables from each schema.
The tables remain empty until they are first queried which saves time in the initialization as the user does not have to wait for Marty to finish copying all the data in the tables before she can start querying the clone.
This behaviour is implemented by creating views instead of tables in the clone.
The views look like the tables that the user expects to find and when they are queried they call a PL/pgSQL function, \textit{view\_select}, that returns the appropriate data.
This function looks for the data in the actual data tables, which Marty creates in the clone, and if these tables are empty the function populates them with data from the history database before returning their contents.

The data tables are created in a special schema called \textit{marty} which is created in the clone database.
It contains the data tables as well as another table called bookkeeping.
The view\_select function uses this table to keep track of which data tables have been populated and which ones are still unpopulated.
The table also contains the querystrings that view\_select uses when it fetches the data from the history database.
See figure \ref{clone-architecture} for an example of a table layout in a clone database.

The views, bookkeeping table, data tables and the view\_select function are described in detail in chapter TODO.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{clone-architecture}
  \caption{Table layout in a clone database}
  \medskip
  \small
  The table \textit{mytable} is actually a view that returns results from the table \textit{data\_myschema\_mytable\_1} which is in the \textit{marty} schema.
  \label{clone-architecture}
\end{figure}

\section{The history database}
The history database is a standard Postgres database.
It is created by a system administrator and contains data that the developers and testers use when they create clone databases.
When the history database has been initialized it contains information about the schema of the master database and a copy of its data.
After the initialization Marty updates the history database with all the changes that are made in the master, both to its data and schema.
Its contents are versioned and, as the name suggests, the user can look up previous states of the master in the history database.

The reason for keeping old versions of the master is the delayed population of the data tables in the clones.
From the moment that a clone database is initialized and until its tables are populated the master database might change.
Tables might be dropped or renamed and rows might be updated or deleted, which could lead to inconsistency in the clone as foreign key relations might break.
The history database offers access to a particular version of the contents of the master database and thus prevents errors of this kind in the clones.

Marty initializes the history database with four tables; \textit{marty\_schemas}, \textit{marty\_tables}, \textit{marty\_columns} and \textit{marty\_updates}.
The first three store information about the schemas, tables and table columns in the master database.
Their contents are mostly copied from the tables \textit{pg\_namespace}, \textit{pg\_class} and \textit{pg\_attributes}, respectively.
The fourth table, \textit{marty\_updates}, keeps a log of version timestamps.
Each version of the contents of the history database has two timestamps associated with it; the local time of the history server when that version was created in the history database and the time of the transaction on the master database that created that version.

Marty copies the data from the tables in the master and stores it in special data tables in the history database.
Each table in the master has a corresponding data table in the history database.
Its schema is similar to the original table but a few columns are added.
They are used for versioning and as a reference when rows are deleted or updated.
There are also no constraints on the data tables or their columns.
They are unnecessary as the data table is only used to store the data that has already been validated on the master.
Constraints might also get in the way, e.g. when the tables need to store different versions of the same row that has a unique constraint on some of its columns.
Another example might be a table that is altered and a not-null constraint is added to one of its columns where null values have been stored in the past.
Therefore there are no constraints on the data tables in the history database.
For an example of the schema of a data table see figure \ref{history-data-table}, and for further details see chapter TODO.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{history-data-table}
  \caption{An example of the schema of a data table in the history database}
  \label{history-data-table}
\end{figure}

\subsection{Populating and updating the history database}
When the history database is initialized its contents are not read directly from the master database.
Instead there is a dedicated instance of Postgres that replicates the master database that is used as a reference for the history.
This instance is called \textit{slave}.
The reason for using another instance to read the schema and data from the master is the format of the write-ahead log, or WAL.

The contents of the WAL are used to update the history database with the changes that are made to the master after the history has been initialized.
This approach was chosen because it makes it possible to read the changes that are made to the master database without inspecting it directy, e.g. with triggers.
That was considered important in the design process for Marty because any change on the master might introduce bugs and reduce its performance.
However, the WAL contains binary information and to be able to read it and use its contents it is necessary to have the database cluster files from the master as a reference.
Instead of implementing a complex algorithm to read the contents of the WAL it was decided to leverage on the recovery feature of Postgres that reads the WAL and applies it to the database cluster.
The slave is therefor started with a copy of the cluster files from the master database and it then replays the WAL into the cluster as it arrives from the master.
As it does so it logs all the operations that it replays and Marty uses this log to find and read the new version of the data from the slave.

The WAL debug log that logs all the operations is not enabled by default and the slave must therefor be compiled with special flags to enable it.
The replay must also be paused after each transaction that has been replayed to give Marty time to read the data from that transaction before the next one is applied.
To be able to do that it is necessary to patch Postgres and so the slave therefor runs on a specially patched version of Postgres.
More information about the slave can be found in chapter TODO.

\section{Advantages and Drawbacks}
The current architecture of Marty that is described in this chapter was chosen because of its simplicity and because it could be implemented in high level code (PL/pgSQL instead of C) which sped up prototyping and simplified the development of Marty.
However, it has a few drawbacks which make it unsuitable for a production ready version of Marty.
The main drawback is the lack of optimization for queries from the clones to the history database; when a user queries a table in a clone database it fetches the complete contents of that table from the history database even if the query should only return a small part of it to the user.
Another issue is the creation of indexes for the tables in the clones; the user can not create indexes for the tables in the clone like she would create them on the master database.
This is because the tables that the user expects to find in the clone database are actually views and it is not possible to create indexes for views in Postgres.

See chapter TODO for a discussion of the current status of Marty, the limitations of the current version and ideas for future works and improvements.

\end{document}
